c
c     test_mbhrouts.f --- test mbhrouts2d/mbhkernels2d
c                          utilities
c
c     This test is auto-generated by jinjaroot based on
c     the file test_mbhrouts.f.j2
c
c     The code generation is used to test all of the
c     possible charge combinations (up to octopole!)
c
c     --- Test explanation -------------
c
c     ________________________
c    |       |       |  T    |
c    |  S    |       |_______|
c    |       |       |   | C |
c    |_______|_______|___|___|
c
c     Sources are randomly placed in the
c     box S = [0,1]\times [0,1]
c     Targets are randomly placed in the
c     boxes T = [2,3]\times[0,1] and
c     its child C = [2.5,3]\times[0,0.5]
c
c     Then the following tests are done
c
c     (a) form multipole expansion directly from sources in S
c     centered at center of S, evaluate at targets in T
c     and compare to true values
c     (b) form local expansion directly from sources in S
c     centered at center of T, evaluate at targets in T
c     and compare to true values
c     (c) form local expansion centered at center of C
c     by translating expansion from part (b), evaluate at
c     targets and compare to truth
c
c     In principle we could test the mpmp and mploc
c     translations but these are used in the formmp and
c     formta routines
c
      
      implicit real *8 (a-h,o-z)
      real *8, allocatable :: source(:,:),targ(:,:),targc(:,:)
      real *8, allocatable :: dipvec(:,:,:)
      real *8, allocatable :: charge(:,:),dipstr(:,:)
      real *8, allocatable :: quadstr(:,:),quadvec(:,:,:)
      real *8, allocatable :: octstr(:,:),octvec(:,:,:)
      real *8, allocatable :: pot(:,:),grad(:,:,:),
     1     hess(:,:,:)
      real *8, allocatable :: potex(:,:),gradex(:,:,:),
     1     hessex(:,:,:), carray(:,:)
      real *8 :: center1(2), center2(2), center3(2)
      complex *16, allocatable :: mbhmpole(:,:), ympole(:,:)
      complex *16, allocatable :: mbhmpole1(:,:,:), ympole1(:,:,:)      
      complex *16, allocatable :: mbhloc(:,:), lloc(:,:)
      complex *16, allocatable :: mbhlocc(:,:), llocc(:,:)
      
      character(len=72) str1
      parameter (ntestmax = 200)
      integer ipass(ntestmax)
      
      complex *16 ima,zbeta
      data ima/(0.0d0,1.0d0)/

      call prini(6,13)

      done = 1
      pi = atan(done)*4

      nsrc = 40
      ntarg = 20
      nd = 3
      allocate(source(2,nsrc),charge(nd,nsrc),dipstr(nd,nsrc))
      allocate(targ(2,ntarg),targc(2,ntarg),dipvec(nd,2,nsrc))
      allocate(quadstr(nd,nsrc),quadvec(nd,3,nsrc))
      allocate(octstr(nd,nsrc),octvec(nd,4,nsrc))      
      allocate(pot(nd,ntarg),grad(nd,2,ntarg),
     1     hess(nd,3,ntarg))
      allocate(potex(nd,ntarg),gradex(nd,2,ntarg),
     1     hessex(nd,3,ntarg))


      do i=1,nsrc
         source(1,i) = hkrand(0)
         source(2,i) = hkrand(0)
         do l = 1,nd
            charge(l,i) = hkrand(0)
            dipstr(l,i) = hkrand(0) 
            dipvec(l,1,i) = hkrand(0)
            dipvec(l,2,i) = hkrand(0)
            quadstr(l,i) = hkrand(0) 
            quadvec(l,1,i) = hkrand(0)
            quadvec(l,2,i) = hkrand(0)
            quadvec(l,3,i) = hkrand(0)
            octstr(l,i) = hkrand(0) 
            octvec(l,1,i) = hkrand(0)
            octvec(l,2,i) = hkrand(0)
            octvec(l,3,i) = hkrand(0)
            octvec(l,4,i) = hkrand(0)   
         enddo
      enddo

      center1(1) = 0.5d0
      center1(2) = 0.5d0

      do i=1,ntarg
         targ(1,i) = 2+hkrand(0)
         targ(2,i) = hkrand(0)
         targc(1,i) = 2.5d0 + 0.5d0*hkrand(0)
         targc(2,i) = 0.5d0*hkrand(0)
      enddo

      center2(1) = 2.5d0
      center2(2) = 0.5d0

      center3(1) = 2.75d0
      center3(2) = 0.25d0

c
c
      beta = 1d-5
      zbeta = ima*beta
      eps = 0.51d-12
      bsize1 = 1
      bsizec = 0.5d0
      rscale = min(abs(zbeta*bsize1/(2.0d0*pi)),1.0d0)
      rscalec = min(abs(zbeta*bsizec/(2.0d0*pi)),1.0d0)
      call l2dterms(eps,ntermsl,ier)

      nterms = ntermsl+5
      nterms1 = 3
      ldc = nterms+10
      allocate(mbhmpole(nd,0:nterms),ympole(nd,0:nterms),
     1     mbhmpole1(nd,0:nterms1,nsrc),ympole1(nd,0:nterms1,nsrc),
     2     mbhloc(nd,0:nterms),lloc(nd,0:nterms),
     2     mbhlocc(nd,0:nterms),llocc(nd,0:nterms),carray(0:ldc,0:ldc))

      call mbh2d_init_carray(carray,ldc)

      call prin2('rscale= *',rscale,1)
      call prinf('nterms = *',nterms,1)
      
      

      write(*,*) "=========================================="
      write(*,*) "Testing suite for mbhrouts/kernels2d"
      write(6,*)
      write(6,*)

      open(unit=33,file='print_testres.txt',access='append')


      do i=1,ntestmax
        ipass(i) = 0
      enddo

      thresh = 2.0d0**(-51)

      ntest = 0

      {%- for rout in mbhDirectRouts %}
c
c     test out = {{ rout.out }} for int-ker = {{ rout.ker }}
c     vs multipole
c

      write(*,*) '--------------------------------------------------'
      write(*,*) 'testing out = {{ rout.out }}, ker = {{ rout.ker }}'

      ntest = ntest+1

      write(*,*) 'multipoles test is test number: ', ntest
      
      call testzero(nd*ntarg,pot)
      call testzero(2*nd*ntarg,grad)
      call testzero(3*nd*ntarg,hess)            
      call testzero(nd*ntarg,potex)
      call testzero(2*nd*ntarg,gradex)
      call testzero(3*nd*ntarg,hessex)            
      call testzero(2*nd*(nterms1+1)*nsrc,mbhmpole1)
      call testzero(2*nd*(nterms1+1)*nsrc,ympole1)
      call testzero(2*nd*(nterms+1),mbhmpole)
      call testzero(2*nd*(nterms+1),ympole)

      {%- if "c" in rout.ker %}
      ifc = 1
      {%- else %}
      ifc = 0
      {%- endif %}
      {%- if "d" in rout.ker %}
      ifd = 1
      {%- else %}
      ifd = 0
      {%- endif %}
      {%- if "q" in rout.ker %}
      ifq = 1
      {%- else %}
      ifq = 0
      {%- endif %}
      {%- if "o" in rout.ker %}
      ifo = 1
      {%- else %}
      ifo = 0
      {%- endif %}

      call mbh2dconvtomp_vec(nd,beta,nsrc,ifc,charge,
     1     ifd,dipstr,dipvec,ifq,quadstr,quadvec,ifo,octstr,
     2     octvec,nterms1,mbhmpole1,ympole1)

      call mbh2dformmpmp_vec(nd,beta,rscale,source,nsrc,
     1     mbhmpole1,ympole1,nterms1,center1,nterms,mbhmpole,ympole)

c      call prin2('mbhmpole *',mbhmpole,nd*2*(nterms+1))
c      call prin2('ympole *',ympole,nd*2*(nterms+1))      
      
      call mbh2dmpeval{{ rout.out }}_vec(nd,beta,rscale,center1,
     1     mbhmpole,ympole,nterms,targ,ntarg,
     2     {% if rout.out == "p" %}pot{% endif %}{% if rout.out == "g" %}pot,grad{% endif %}{% if rout.out == "h" %}pot,grad,hess{% endif %})

      call mbh2d_direct{{ rout.ker }}{{ rout.out }}_vec(nd,beta,source,nsrc,
     1     {% if "c" in rout.ker %}charge,{% endif %}{% if "d" in rout.ker %}dipstr,dipvec,{% endif %}{% if "q" in rout.ker %}quadstr,quadvec,{% endif %}{% if "o" in rout.ker %}octstr,octvec,{% endif %}
     2     targ,ntarg,{% if rout.out == "p" or rout.out == "g" or rout.out == "h" %}potex,{% endif %}{% if rout.out == "g" or rout.out == "h" %}gradex,{% endif %}{% if rout.out == "h" %}hessex,{% endif %}thresh)

      {%- if rout.out == "p" %}
      call testerr(nd*ntarg,potex,pot,errpot)
      write(*,*) errpot
      if(errpot .lt. eps) ipass(ntest) = 1
      {%- endif %}
      {%- if rout.out == "g" %}
      call testerr(nd*ntarg,potex,pot,errpot)
      call testerr(2*nd*ntarg,gradex,grad,errgrad)
      write(*,*) errpot, errgrad
      if(errpot .lt. eps .and. errgrad/10 .lt. eps) ipass(ntest) = 1
      {%- endif %}
      {%- if rout.out == "h" %}      
      call testerr(nd*ntarg,potex,pot,errpot)
      call testerr(2*nd*ntarg,gradex,grad,errgrad)
      call testerr(3*nd*ntarg,hessex,hess,errhess)
      write(*,*) errpot, errgrad, errhess
      if(errpot .lt. eps .and. errgrad/10 .lt. eps
     1     .and. errhess/100 .lt. eps)
     1     ipass(ntest) = 1
      {%- endif %}

      ntest = ntest+1

      write(*,*) 'local exps test is test number: ', ntest
      
      call testzero(nd*ntarg,pot)
      call testzero(2*nd*ntarg,grad)
      call testzero(3*nd*ntarg,hess)            
      call testzero(2*nd*(nterms+1),mbhloc)
      call testzero(2*nd*(nterms+1),lloc)

      call mbh2dformtamp_vec(nd,beta,rscale,source,nsrc,
     1     mbhmpole1,ympole1,nterms1,center2,nterms,mbhloc,lloc)

c      call prin2('mbhloc *',mbhloc,2*nd*(nterms+1))
c      call prin2('lloc *',lloc,2*nd*(nterms+1))      
      
      call mbh2dtaeval{{ rout.out }}_vec(nd,beta,rscale,center2,
     1     mbhloc,lloc,nterms,targ,ntarg,
     2     {% if rout.out == "p" %}pot{% endif %}{% if rout.out == "g" %}pot,grad{% endif %}{% if rout.out == "h" %}pot,grad,hess{% endif %})

c
      {%- if rout.out == "p" %}
      call testerr(nd*ntarg,potex,pot,errpot)
      write(*,*) errpot
      if(errpot .lt. eps) ipass(ntest) = 1
      {%- endif %}
      {%- if rout.out == "g" %}
      call testerr(nd*ntarg,potex,pot,errpot)
      call testerr(2*nd*ntarg,gradex,grad,errgrad)
      write(*,*) errpot, errgrad
      if(errpot .lt. eps .and. errgrad/10 .lt. eps) ipass(ntest) = 1
      {%- endif %}
      {%- if rout.out == "h" %}      
      call testerr(nd*ntarg,potex,pot,errpot)
      call testerr(2*nd*ntarg,gradex,grad,errgrad)
      call testerr(3*nd*ntarg,hessex,hess,errhess)
      write(*,*) errpot, errgrad, errhess
      if(errpot .lt. eps .and. errgrad/10 .lt. eps
     1     .and. errhess/100 .lt. eps)
     1     ipass(ntest) = 1
      {%- endif %}

      {% if rout.out == "h" and rout.ker == "cdqo" %}
c     only need to test locloc for one case really...
      
      ntest = ntest+1

      write(*,*) 'locloc map test is test number: ', ntest
      
      call testzero(nd*ntarg,pot)
      call testzero(2*nd*ntarg,grad)
      call testzero(3*nd*ntarg,hess)            
      call testzero(nd*ntarg,potex)
      call testzero(2*nd*ntarg,gradex)
      call testzero(3*nd*ntarg,hessex)            
      call testzero(2*nd*(nterms+1),mbhlocc)
      call testzero(2*nd*(nterms+1),llocc)

      call mbh2dlocloc_vec(nd,beta,rscale,center2,mbhloc,lloc,
     1     nterms,rscalec,center3,mbhlocc,llocc,nterms,carray,ldc)


c      call prin2('mbhloc *',mbhloc,2*nd*(nterms+1))
c      call prin2('lloc *',lloc,2*nd*(nterms+1))      
      
      call mbh2dtaeval{{ rout.out }}_vec(nd,beta,rscalec,center3,
     1     mbhlocc,llocc,nterms,targc,ntarg,
     2     {% if rout.out == "p" %}pot{% endif %}{% if rout.out == "g" %}pot,grad{% endif %}{% if rout.out == "h" %}pot,grad,hess{% endif %})

      call mbh2d_direct{{ rout.ker }}{{ rout.out }}_vec(nd,beta,source,nsrc,
     1     {% if "c" in rout.ker %}charge,{% endif %}{% if "d" in rout.ker %}dipstr,dipvec,{% endif %}{% if "q" in rout.ker %}quadstr,quadvec,{% endif %}{% if "o" in rout.ker %}octstr,octvec,{% endif %}
     2     targc,ntarg,{% if rout.out == "p" or rout.out == "g" or rout.out == "h" %}potex,{% endif %}{% if rout.out == "g" or rout.out == "h" %}gradex,{% endif %}{% if rout.out == "h" %}hessex,{% endif %}thresh)

      
c
      {%- if rout.out == "p" %}
      call testerr(nd*ntarg,potex,pot,errpot)
      write(*,*) errpot
      if(errpot .lt. eps) ipass(ntest) = 1
      {%- endif %}
      {%- if rout.out == "g" %}
      call testerr(nd*ntarg,potex,pot,errpot)
      call testerr(2*nd*ntarg,gradex,grad,errgrad)
      write(*,*) errpot, errgrad
      if(errpot .lt. eps .and. errgrad/10 .lt. eps) ipass(ntest) = 1
      {%- endif %}
      {%- if rout.out == "h" %}      
      call testerr(nd*ntarg,potex,pot,errpot)
      call testerr(2*nd*ntarg,gradex,grad,errgrad)
      call testerr(3*nd*ntarg,hessex,hess,errhess)
      write(*,*) errpot, errgrad, errhess
      if(errpot .lt. eps .and. errgrad/10 .lt. eps
     1     .and. errhess/100 .lt. eps)
     1     ipass(ntest) = 1
      {%- endif %}
      {%- endif %}

      {%- endfor %}

      isum = 0
      do i=1,ntest
        isum = isum+ipass(i)
      enddo

      write(*,*) '--------------------------------------------------'
      
      call prinf('ipass *',ipass,ntest)

      write(*,'(a,i2,a,i2,a)') 'Successfully completed ',isum,
     1   ' out of ',ntest,' tests in mbhrouts/kernel2d testing suite'
      write(33,'(a,i2,a,i2,a)') 'Successfully completed ',isum,
     1   ' out of ',ntest,' tests in mbhrouts/kernel2d testing suite'
      close(33)
      


      stop
      end
c      
c
c

      subroutine testzero(n,v)
      implicit real *8 (a-h,o-z)
      real *8 :: v(*)
      
      do i = 1,n
         v(i)=0
      enddo

      return
      end

      subroutine testerr(n,vex,v,errv)
      implicit real *8 (a-h,o-z)
      real *8 :: v(*), vex(*)
      
      s = 0
      s1 = 0
      do i = 1,n
         s = s+(vex(i)-v(i))**2
         s1 = s1+(vex(i))**2
      enddo

      errv=sqrt(s/s1)
      return
      end
    
