c
c     test_mbhfmm2d.f --- test modified biharmonic fmm
c
c     This test is auto-generated by jinjaroot based on
c     the file test_mbhfmm2d.f.j2
c
c     The code generation is used to test all of the
c     possible charge combinations (up to octopole!)
c
c     --- Test explanation -------------
c
c     Sources and targets are randomly placed in a shifted
c     unit box and random charges (up to octopole strength)
c     are assigned to each source. Then, the
c     output of the FMM is compared to direct evaluation
c      
      implicit real *8 (a-h,o-z)
      real *8, allocatable :: source(:,:),targ(:,:)
      real *8, allocatable :: dipvec(:,:,:)
      real *8, allocatable :: charge(:,:),dipstr(:,:)
      real *8, allocatable :: quadstr(:,:),quadvec(:,:,:)
      real *8, allocatable :: octstr(:,:),octvec(:,:,:)
      real *8, allocatable :: pot(:,:),grad(:,:,:),
     1     hess(:,:,:)
      real *8, allocatable :: pottarg(:,:),gradtarg(:,:,:),
     1     hesstarg(:,:,:)
      real *8, allocatable :: potex(:,:),gradex(:,:,:),
     1     hessex(:,:,:)
      real *8, allocatable :: pottargex(:,:),gradtargex(:,:,:),
     1     hesstargex(:,:,:)
      real *8 :: zshift(2)
      
      character(len=72) str1
      parameter (ntestmax = 200)
      integer ipass(ntestmax)
      
      complex *16 ima,zbeta
      data ima/(0.0d0,1.0d0)/

      call prini(6,13)

      done = 1
      pi = atan(done)*4

c     make nsrc/ntarg big enough to trigger fmm routs
c     but no need to test result everywhere

      nsrc = 4000
      ntarg = 3000
      ntt = min(ntarg,20)
      nst = min(nsrc,20)
      
      nd = 3
      allocate(source(2,nsrc),charge(nd,nsrc),dipstr(nd,nsrc))
      allocate(targ(2,ntarg),dipvec(nd,2,nsrc))
      allocate(quadstr(nd,nsrc),quadvec(nd,3,nsrc))
      allocate(octstr(nd,nsrc),octvec(nd,4,nsrc))      
      allocate(pot(nd,nsrc),grad(nd,2,nsrc),
     1     hess(nd,3,nsrc))
      allocate(potex(nd,nst),gradex(nd,2,nst),
     1     hessex(nd,3,nst))
      allocate(pottarg(nd,ntarg),gradtarg(nd,2,ntarg),
     1     hesstarg(nd,3,ntarg))
      allocate(pottargex(nd,ntt),gradtargex(nd,2,ntt),
     1     hesstargex(nd,3,ntt))


      zshift(1) = 1.7d0
      zshift(2) = -0.3d0

      do i=1,nsrc
         source(1,i) = zshift(1)+hkrand(0)
         source(2,i) = zshift(2)+hkrand(0)
         do l = 1,nd
            charge(l,i) = hkrand(0)
            dipstr(l,i) = hkrand(0) 
            dipvec(l,1,i) = hkrand(0)
            dipvec(l,2,i) = hkrand(0)
            quadstr(l,i) = hkrand(0) 
            quadvec(l,1,i) = hkrand(0)
            quadvec(l,2,i) = hkrand(0)
            quadvec(l,3,i) = hkrand(0)
            octstr(l,i) = hkrand(0) 
            octvec(l,1,i) = hkrand(0)
            octvec(l,2,i) = hkrand(0)
            octvec(l,3,i) = hkrand(0)
            octvec(l,4,i) = hkrand(0)   
         enddo
      enddo

      do i=1,ntarg
         targ(1,i) = zshift(1)+hkrand(0)
         targ(2,i) = zshift(2)+hkrand(0)
      enddo
c
c
      beta = 1d-5
      zbeta = ima*beta
      eps = 0.51d-12
      thresh = 1d-15

      write(*,*) "=========================================="
      write(*,*) "Testing suite for mbhfmm2d "
      write(6,*)
      write(6,*)

      open(unit=33,file='print_testres.txt',access='append')


      do i=1,ntestmax
        ipass(i) = 0
      enddo

      ntest = 0

      {%- for rout in mbhDirectRouts %}
c
c     test out = {{ rout.out }} for int-ker = {{ rout.ker }}
c     vs multipole
c

      write(*,*) '--------------------------------------------------'
      write(*,*) 'testing out = {{ rout.out }}, ker = {{ rout.ker }}'

      ntest = ntest+1

      write(*,*) 'test number: ', ntest
      
      call testzero(nd*nsrc,pot)
      call testzero(2*nd*nsrc,grad)
      call testzero(3*nd*nsrc,hess)            
      call testzero(nd*ntarg,pottarg)
      call testzero(2*nd*ntarg,gradtarg)
      call testzero(3*nd*ntarg,hesstarg)            
      call testzero(nd*nst,potex)
      call testzero(2*nd*nst,gradex)
      call testzero(3*nd*nst,hessex)            
      call testzero(nd*ntt,pottargex)
      call testzero(2*nd*ntt,gradtargex)
      call testzero(3*nd*ntt,hesstargex)            

      {%- if "c" in rout.ker %}
      ifc = 1
      {%- else %}
      ifc = 0
      {%- endif %}
      {%- if "d" in rout.ker %}
      ifd = 1
      {%- else %}
      ifd = 0
      {%- endif %}
      {%- if "q" in rout.ker %}
      ifq = 1
      {%- else %}
      ifq = 0
      {%- endif %}
      {%- if "o" in rout.ker %}
      ifo = 1
      {%- else %}
      ifo = 0
      {%- endif %}
      

      call mbh2d_direct{{ rout.ker }}{{ rout.out }}_vec(nd,beta,source,nsrc,
     1     {% if "c" in rout.ker %}charge,{% endif %}{% if "d" in rout.ker %}dipstr,dipvec,{% endif %}{% if "q" in rout.ker %}quadstr,quadvec,{% endif %}{% if "o" in rout.ker %}octstr,octvec,{% endif %}
     2     targ,ntt,{% if rout.out == "p" or rout.out == "g" or rout.out == "h" %}pottargex,{% endif %}{% if rout.out == "g" or rout.out == "h" %}gradtargex,{% endif %}{% if rout.out == "h" %}hesstargex,{% endif %}thresh)

      call mbh2d_direct{{ rout.ker }}{{ rout.out }}_vec(nd,beta,source,nsrc,
     1     {% if "c" in rout.ker %}charge,{% endif %}{% if "d" in rout.ker %}dipstr,dipvec,{% endif %}{% if "q" in rout.ker %}quadstr,quadvec,{% endif %}{% if "o" in rout.ker %}octstr,octvec,{% endif %}
     2     source,nst,{% if rout.out == "p" or rout.out == "g" or rout.out == "h" %}potex,{% endif %}{% if rout.out == "g" or rout.out == "h" %}gradex,{% endif %}{% if rout.out == "h" %}hessex,{% endif %}thresh)

      iper=0
      ifpgh=0
      ifpghtarg=0
      {% if rout.out == "p" %}
      ifpgh=1
      ifpghtarg = 1
      {% endif %}
      {% if rout.out == "g" %}
      ifpgh=2
      ifpghtarg=2
      {% endif %}
      {% if rout.out == "h" %}
      ifpgh=3
      ifpghtarg=3
      {% endif %}

      call cpu_time(t1)
c$    t1 = omp_get_wtime()      
      call mbhfmm2d(nd,eps,beta,nsrc,source,ifc,charge,
     1     ifd,dipstr,dipvec,ifq,quadstr,quadvec,ifo,
     2     octstr,octvec,iper,ifpgh,pot,grad,hess,ntarg,targ,ifpghtarg,
     3     pottarg,gradtarg,hesstarg,ier)
      call cpu_time(t2)
c$    t2 = omp_get_wtime()      

      write(*,*) 'time for fmm call  ........ ', t2-t1
      write(*,*) 'points per second  ........ ', (nsrc+ntarg)/(t2-t1)
      

c      call prin2('potex *',potex,nd*nst)
      

c      call prin2('pot *',pot,nd*nst)
      

      {%- if rout.out == "p" %}
      call testerr(nd*ntt,pottargex,pottarg,errpottarg)
      call testerr(nd*nst,potex,pot,errpot)
      write(*,*) errpot, errpottarg
      if(errpottarg .lt. eps .and. errpot .lt. eps) ipass(ntest) = 1
      {%- endif %}
      {%- if rout.out == "g" %}
      call testerr(nd*ntt,pottargex,pottarg,errpottarg)
      call testerr(nd*nst,potex,pot,errpot)
      call testerr(2*nd*ntt,gradtargex,gradtarg,errgradtarg)
      call testerr(2*nd*nst,gradex,grad,errgrad)
      write(*,*) errpot, errpottarg, errgrad, errgradtarg
      if(errpot .lt. eps .and. errpottarg .lt. eps .and.
     1     errgrad/10 .lt. eps .and. errgradtarg/10 .lt. eps)
     2     ipass(ntest) = 1
      {%- endif %}
      {%- if rout.out == "h" %}      
      call testerr(nd*ntt,pottargex,pottarg,errpottarg)
      call testerr(nd*nst,potex,pot,errpot)
      call testerr(2*nd*ntt,gradtargex,gradtarg,errgradtarg)
      call testerr(2*nd*nst,gradex,grad,errgrad)
      call testerr(3*nd*ntt,hesstargex,hesstarg,errhesstarg)
      call testerr(3*nd*nst,hessex,hess,errhess)
      write(*,*) errpot, errpottarg, errgrad, errgradtarg, errhess,
     1     errhesstarg
      if(errpot .lt. eps .and. errpottarg .lt. eps .and.
     1     errgrad/10 .lt. eps .and. errgradtarg/10 .lt. eps .and.
     1     errhess/100 .lt. eps .and. errhesstarg/100 .lt. eps)
     1     ipass(ntest) = 1
      {%- endif %}

c      stop

      if (ipass(ntest) .eq. 1) write(*,*) '... test passed '
      
      {%- endfor %}

      isum = 0
      do i=1,ntest
        isum = isum+ipass(i)
      enddo

      write(*,*) '--------------------------------------------------'
      
      call prinf('ipass *',ipass,ntest)

      write(*,'(a,i2,a,i2,a)') 'Successfully completed ',isum,
     1   ' out of ',ntest,' tests in mbhfmm2d testing suite'
      write(33,'(a,i2,a,i2,a)') 'Successfully completed ',isum,
     1   ' out of ',ntest,' tests in mbhfmm2d testing suite'
      close(33)
      


      stop
      end
c      
c
c

      subroutine testzero(n,v)
      implicit real *8 (a-h,o-z)
      real *8 :: v(*)
      
      do i = 1,n
         v(i)=0
      enddo

      return
      end

      subroutine testerr(n,vex,v,errv)
      implicit real *8 (a-h,o-z)
      real *8 :: v(*), vex(*)
      
      s = 0
      s1 = 0
      do i = 1,n
         s = s+(vex(i)-v(i))**2
         s1 = s1+(vex(i))**2
      enddo

      errv=sqrt(s/s1)
      return
      end
    
